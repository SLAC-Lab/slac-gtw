<?php
/**
 * @file
 * Code for the SLAC IGP FEED feature.
 */

include_once 'slac_igp_feed.features.inc';

/**
 * Implements hook_views_api_alter
 */
function slac_igp_feed_views_api_alter(&$list) {
  // looking for views template in the module directory
  $list['slac_igp_feed']['template path'] = drupal_get_path('module', 'slac_igp_feed') . '/templates';
}

/**
 * Implements hook_preprocess_views_view
 * We manipulate the grouped result so only the next 3 grouped
 * days items will appear, each day should only display 2 entries
 */
function slac_igp_feed_preprocess_views_view(&$vars) {
  $view = $vars['view'];
  if ($view->name === 'calendar') {
    $library = libraries_load('slac_igp_importers');
    if (empty($library['loaded'])) {
      return;
    }
    
    if ($vars['rows'] == '') {
      return;
    }
    
    $html = str_get_html($vars['rows']);
    $ret = $html->find('div[class=views-row-grouped]');
    if (count($ret) > 3) {
      // only display 3 upcoming grouped days
      $ret = array_slice($ret, 0, 3);
    }
    
    foreach ($ret as $key => $group) {
      $title[$key] = $group->find('h3', 0)->plaintext;
      $group_items = $group->find('div[class=views-row]');
      if (count($group_items) > 2) {
        // for each grouped day, only 2 events will show
        $ret[$key] = array_slice($group_items, 0, 2);
      } else {
        $ret[$key] = $group_items;
      }
    }
    
    $output = '';
    foreach ($ret as $key => $views_rows) {
      $output .= '<div class="views-row-grouped">';
      $output .= '<h3>' . $title[$key] . '</h3>';
      foreach ($views_rows as $row) {
        $output .= $row->__toString();
      }
      $output .= '</div>';
    }
    
    if ($output !== '') {
      $vars['rows'] = $output;
    }
  }
}

/**
 * Implements hook_node_insert
 * Automatically insert items into nodequeue based on type: internal/external
 * and if the item is promoted or not
 * IMPORTANT: we are assuming RSS feeds are sorted in decending order with newest items first
 */
function slac_igp_feed_node_insert($node) {
  if ($node->type === 'news_article') {
    module_load_include('inc', 'slac_igp_feed', 'slac_igp_feed.nodequeue');
    $lang = $node->language;
    $promoted = (bool) $node->promote;
    // if news is only internal
    if (count($node->field_news_type[$lang]) === 1) {
      if ($node->field_news_type[$lang][0]['value'] === 'internal') {
        $subqueue = ($promoted) ? 'Featured Lab News' : 'Lab News';
          slac_igp_feed_node_add($node->nid, $subqueue, FALSE);      
      }
      // external news
      else {
        slac_igp_feed_node_add($node->nid, 'SLAC Science', $promoted);
      }
    }
    // if the news has "external", (regardless if it is both internal/external), it will be added to SLAC Science
    if (count($node->field_news_type[$lang]) === 2) {
      // (If external + promoted, add to the front, otherwise it will be at end of the queue
      slac_igp_feed_node_add($node->nid, 'SLAC Science', $promoted);
    }
  }
}

/**
 * Implements hook_node_update
 */
function slac_igp_feed_node_update($node) {
  if ($node->type === 'news_article') {
    module_load_include('inc', 'slac_igp_feed', 'slac_igp_feed.nodequeue');
    $lang = $node->language;
    $promoted = (bool) $node->promote;
    if (count($node->field_news_type[$lang]) === 1) {
      if ($node->field_news_type[$lang][0]['value'] === 'internal') {
        if ($promoted) {
          slac_igp_feed_node_remove($node->nid, 'Lab News');
          slac_igp_feed_node_remove($node->nid, 'SLAC Science');
          slac_igp_feed_node_add($node->nid, 'Featured Lab News', TRUE);
        }
        else {
          slac_igp_feed_node_remove($node->nid, 'Featured Lab News');
          slac_igp_feed_node_remove($node->nid, 'SLAC Science');
          slac_igp_feed_node_add($node->nid, 'Lab News', TRUE);
        } 
      }
      // external
      else {
        $subqueue = slac_igp_feed_get_subqueue('SLAC Science');
        if ($promoted) {
          slac_igp_feed_node_move($node->nid, $subqueue, TRUE);
        }
        else {
          $position = nodequeue_get_subqueue_position($subqueue->sqid, $node->nid);
          if ($position == 1) {
            nodequeue_queue_down($subqueue, 1);
          }
        }
      }           
    }
  }
}