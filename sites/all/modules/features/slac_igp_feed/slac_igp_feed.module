<?php
/**
 * @file
 * Code for the SLAC IGP FEED feature.
 */

include_once 'slac_igp_feed.features.inc';

DEFINE('FEATURED_NEWS', 'Featured News');
DEFINE('LAB_NEWS', 'Lab News');
DEFINE('SLAC_SCIENCE', 'SLAC Science');

/**
 * Implements hook_cron
 * we are automatically expiring older contents from the queue
 */
function slac_igp_feed_cron() {
  // get the configurations for all of the subqueues
  module_load_include('inc', 'slac_igp_feed', 'slac_igp_feed.nodequeue');
  $queue = slac_igp_feed_get_queue();
  $subqueues = slac_igp_feed_get_subqueues_all();
  foreach ($subqueues as $subqueue) {
    $varname = _slac_igp_feed_subqueue_expiration_varname($queue->qid, $subqueue->sqid);
    // get the configuration
    $config = variable_get($varname, array());
    if (!empty($config) && ($config['date'] !== '' && $config['exclude'] !== '')) {
      // 1. load all the nids from the subqueue
      // 2. exclude top x number
      $nodes = nodequeue_load_nodes($subqueue->sqid, FALSE, $config['exclude'], 1000);
      foreach ($nodes as $node) {
        // check for date interval greater than our configuration
        if (REQUEST_TIME - $node->created > $config['date'] * 604800) {
          // take it out of the queue
          nodequeue_subqueue_remove_node($subqueue->sqid, $node->nid); 
        }
      }
    }
  }
}

/**
 * Implements hook_form_alter
 * Adding some node queue expiration logic that will keep the queue short
 */ 
function slac_igp_feed_form_alter(&$form, &$form_state, $form_id) {
  if (substr($form_id, 0, strrpos($form_id, '_')) !== 'nodequeue_arrange_subqueue_form') {
    return;
  }  
  
  $var_name = _slac_igp_feed_subqueue_expiration_varname($form['nodes']['#queue']['qid'], $form['nodes']['#subqueue']['sqid']);
  $config = variable_get($var_name, array());    
  // building a configuration form
  $form['subqueue_expiration'] = array(
  '#type' => 'fieldset', 
  '#title' => t('Expiration settings'), 
  '#description' => t('The configuration below will allow older items in the queue to expire and be removed from the queue, you also have the ability to exclude this for the top [X] number of items in the queue.'),
  '#collapsible' => TRUE, 
  '#collapsed' => TRUE,
  );
  
  $form['subqueue_expiration']['example'] = array(
    '#prefix' => '<div class="messages status">',
    '#markup' => t('For example, if you choose 2 weeks for the %date option and excluding 3 items from the top, it means that anything created older than 2 weeks will be periodically removed from the queue but 3 items on the top of this queue will remain there regardless of their posted date.', array('%date' => 'Dating back to')),
    '#suffix' => '</div>',
  );
  
  $form['subqueue_expiration']['subqueue_expiration_date'] = array(
    '#type' => 'select',
    '#title' => 'Dating back to',
    '#description' => t('Select how old an item is (based on Post Date) before we take it out of the queue.'),
    '#options' => array(
      '' => t('--Please select--'),
      1 => t('1 Week'),
      2 => t('2 Weeks'),
      3 => t('3 Weeks'),
      4 => t('4 Weeks'),
    ),
    '#default_value' => (!empty($config)) ? $config['date'] : '',
  );
  
  $options = array('' => t('--Please Select--'));
  for($i = 1; $i <= 20; $i++) {
    $options[$i] = $i;
  }
  
  $form['subqueue_expiration']['subqueue_expiration_exclude'] = array(
    '#type' => 'select',
    '#title' => 'Exclude top items',
    '#description' => t('Select how many item(s) on the top of the queue that should remain in the queue (excluded from the expiration settings.)'),
    '#options' => $options,
    '#default_value' => (!empty($config)) ? $config['exclude'] : '',
  );
  
  $form['actions']['submit']['#submit'][] = 'slac_igp_feed_subqueue_expiration_submit';
  $form['#validate'][] = 'slac_igp_feed_subqueue_expiration_validate';
}

/**
 * Form validation callback
 */
function slac_igp_feed_subqueue_expiration_validate($form, &$form_state) {
  $v = $form_state['values']['subqueue_expiration'];
  if (!empty($v['subqueue_expiration_date']) && empty($v['subqueue_expiration_exclude'])) {
    form_set_error('subqueue_expiration][subqueue_expiration_exclude', t('You must select number of items to exclude as well.'));
  }
  if (!empty($v['subqueue_expiration_exclude']) && empty($v['subqueue_expiration_date'])) {
    form_set_error('subqueue_expiration][subqueue_expiration_date', t('You must select created date as well.'));
  }
}

/** 
 * Form submission callback
 */
function slac_igp_feed_subqueue_expiration_submit($form, &$form_state) {
  $config = array(
    'date' => $form_state['values']['subqueue_expiration']['subqueue_expiration_date'],
    'exclude' => $form_state['values']['subqueue_expiration']['subqueue_expiration_exclude'],
  );
  // we are storing the configuration setting in variables like
  //nodequeue_subqueue_expiration_[qid]_[sqid]
  $var_name = _slac_igp_feed_subqueue_expiration_varname($form['nodes']['#queue']['qid'], $form['nodes']['#subqueue']['sqid']);
  variable_set($var_name, $config);
}

/**
 * Helper function that returns a variable name for the 
 * subqueue expiration configuration
 */
function _slac_igp_feed_subqueue_expiration_varname($qid, $sqid) {
  $var_name = array(
    'nodequeue_subqueue_expiration',
    $qid,
    $sqid,
  );
  return implode('_', $var_name);
}

/**
 * Implements hook_views_api_alter
 */
function slac_igp_feed_views_api_alter(&$list) {
  // looking for views template in the module directory
  $list['slac_igp_feed']['template path'] = drupal_get_path('module', 'slac_igp_feed') . '/templates';
}

/**
 * Implements hook_preprocess_views_view
 * We manipulate the grouped result so only the next 3 grouped
 * days items will appear, each day should only display 2 entries
 */
function slac_igp_feed_preprocess_views_view(&$vars) {
  $view = $vars['view'];
  if ($view->name === 'calendar') {
    $library = libraries_load('slac_igp_importers');
    if (empty($library['loaded'])) {
      return;
    }
    
    if ($vars['rows'] == '') {
      return;
    }
    
    $html = str_get_html($vars['rows']);
    $ret = $html->find('div[class=views-row-grouped]');
    if (count($ret) > 3) {
      // only display 3 upcoming grouped days
      $ret = array_slice($ret, 0, 3);
    }
    
    $more = array();
    foreach ($ret as $key => $group) {
      $title[$key] = $group->find('h3', 0)->plaintext;
      $group_items = $group->find('div[class=views-row]');
      if (count($group_items) > 2) {
        // for each grouped day, only 2 events will show
        $ret[$key] = array_slice($group_items, 0, 2);
        // $additional = count($group_items) - 2;
        // $text = ($additional > 1) ? $additional . ' more events' : $additional . ' more event';
        //$more[$key] = l( 'More events', 'http://news.slac.stanford.edu/calendar/all/' . date('Y-m-d', strtotime($title[$key] . ' ' . date('Y'))));  /*removing to fix bug -vf*/
        $more[$key] = l( 'More events', 'http://news.slac.stanford.edu/calendar/all/');
      } else {
        $ret[$key] = $group_items;
      }
    }
    
    $output = '';
    foreach ($ret as $key => $views_rows) {
      $output .= '<div class="views-row-grouped">';
      $title_date = explode(' ', $title[$key]);
      $month = '<span class="month">' . $title_date[0] . '</span>';
      $day = '<span class="day">' . $title_date[1] . '</span>';
      $output .= '<h3>' . $month . $day . '</h3>';
      foreach ($views_rows as $row) {
        $output .= $row->__toString();
      }
      if (array_key_exists($key, $more)) {
        $output .= '<span class="more views-row views-row-last">' . $more[$key] . ' &raquo;</span>';
      }
      $output .= '</div>';
    }
    
    if ($output !== '') {
      $vars['rows'] = $output;
    }
  }
}

/**
 * Implements hook_node_insert
 * Automatically insert items into nodequeue based on type: internal/external
 * and if the item is promoted or not
 * IMPORTANT: we are assuming RSS feeds are sorted in decending order with newest items first
 */
function slac_igp_feed_node_insert($node) {
  if ($node->type === 'news_article') {
    module_load_include('inc', 'slac_igp_feed', 'slac_igp_feed.nodequeue');
    $lang = $node->language;
    if (empty($node->field_news_type[$lang])) {
      return;
    }
    switch($node->field_news_type[$lang][0]['value']) {
      case 'internal':
        slac_igp_feed_node_add($node->nid, LAB_NEWS, FALSE);
      break;
      case 'external':
        slac_igp_feed_node_add($node->nid, SLAC_SCIENCE, FALSE);
      break;
    }
  }
}

/**
 * Implements hook_node_presave().
 *
 * @param $node
 */
function slac_igp_feed_node_presave($node) {
  if ($node->type === 'news_article') {
    module_load_include('inc', 'slac_igp_feed', 'slac_igp_feed.nodequeue');

    $changed = !isset($node->original) || ($node->promote != $node->original->promote);

    $subqueues = array(FEATURED_NEWS, LAB_NEWS, SLAC_SCIENCE);

    $new_types = field_get_items('node', $node, 'field_news_type');
    $new_type = $new_types[0]['value'];

    // We don't think we've changed so far, but see if we switched the news type
    if (!$changed && isset($node->original)) {
      $old_types = field_get_items('node', $node->original, 'field_news_type');
      $old_type = $old_types[0]['value'];
      $changed = $old_type != $new_type;
    }
    
    // only update if the promoted is changed or if it's a new node, if not then other factors will cause the nodequeues to be shifted
    if ($changed) {
      // if the news article is promoted, take it out of other queue and place it into the featured news queue
      if ($node->promote) {
        slac_igp_feed_node_remove($node->nid, $subqueues);
        slac_igp_feed_node_add($node->nid, FEATURED_NEWS, TRUE);
      }
      else {
        // If the type changedâ€¦
        switch ($new_type) {
          case 'internal':
            slac_igp_feed_node_remove($node->nid, $subqueues);
            slac_igp_feed_node_add($node->nid, LAB_NEWS, TRUE);
            break;
          case 'external':
            slac_igp_feed_node_remove($node->nid, $subqueues);
            slac_igp_feed_node_add($node->nid, SLAC_SCIENCE, TRUE, -1);
            break;
        }
      }
    }
  }
}

/**
 * Implements hook_views_pre_render(&$view)
 * Custom format display event date if today >= start day:  Through <day-short-name>, <month-name> <day-date>
 */
function slac_igp_feed_views_pre_render(&$view) {
  if ($view->name == 'access_information') {
    if ($view->current_display == 'block') {
      foreach ($view->result as $key => $row) {
        if (isset($row->field_field_event_date)) {
          if (!empty($row->field_field_event_date)) {
            foreach ($row->field_field_event_date as $key_access => $date_access_info) {
              $start_date = $date_access_info['raw']['value'];
              $end_date = $date_access_info['raw']['value2'];
              if (REQUEST_TIME >= strtotime($start_date)) {
                $view->result[$key]->field_field_event_date[$key_access]['rendered']['#markup'] = t('Through <span class="date-display-end">@date_time</span>',array('@date_time' => format_date(strtotime($end_date),'access_information')));
              }
            }
          }
        }
      }
    }
  }
}
